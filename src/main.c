/*
  This is an implementation to convert a valid gltf model generated by
  gltfpack tool (https://github.com/zeux/meshoptimizer/releases/v0.20) to
  an unlit textured single-mesh binary model file.

                             FILE STRUCTURE
                      +--------------------------+
                      |          HEADER          |
                      +--------------------------+
                      |IndicesCount : u32        |
                      |IndicesSize  : u32        |
                      |VerticesSize : u32        |
                      +--------------------------+
                      |        MODEL DATA        |
                      +--------------------------+
                      |Indices      : u16 *      |
                      |Vertices     : Vertex *   | //NOTE: See atribs bellow
                      +--------------------------+
*/

#include "stdio.h"

#define WIN32_LEAN_AND_MEAN
#include "windows.h"

#define CGLTF_IMPLEMENTATION
#define CGLTF_VALIDATE_ENABLE_ASSERTS 1
#include "cgltf.h"

#include "typedefs.c"
#include "linear_alloc.c"
#include "win32_logger.c"
#include "misc.c"

#pragma pack(push, 1)
typedef struct Vertex {
  u16 x, y, z;
  s8 nx, ny, nz;
  u16 u, v;
} Vertex;
#pragma pack(pop)

typedef struct Model
{
  u32 indicesCount;
  u32 indicesSize;
  u32 verticesSize;
  u16 *indices;
  Vertex *vertices;
} Model;

int main(int argc, char **argv)
{ 
  if (argc != 3) {
    Log("Usage: gltf2custom [input: *.gltf/glb] [output]");
    return 1;
  }

  LARGE_INTEGER freq, c1;
  QueryPerformanceFrequency(&freq);
  QueryPerformanceCounter(&c1);
  
  Model model = {0};
  char *inputPath = argv[1];
  char *outputPath = argv[2];
  
  Memory memory = {0};
  MemInit(
    &memory, 
    VirtualAlloc(NULL, 1*GB, MEM_COMMIT | MEM_RESERVE, PAGE_READWRITE),
    4*GB
  );

  cgltf_options options = {0};
  cgltf_data* data = NULL;
  if (cgltf_parse_file(&options, inputPath, &data) == cgltf_result_success)
  {
    // Custom model validations
    CheckIf(fast_strcmp(data->asset.generator, "gltfpack 0.20", 13) == 0,
            "gltfpack 0.20 is not installed")
    CheckIf(!data->accessors->is_sparse,
            "Sparse accesors are not supported")
    CheckIf(data->meshes_count == 1,
            "The model must be a single mesh")
    CheckIf(data->meshes->primitives_count == 1,
            "The model's primitives must be merged to a single mesh")
    CheckIf(data->meshes->primitives->type >= cgltf_primitive_type_triangles,
            "The model must be triangulated")
    CheckIf(data->meshes->primitives->attributes->data->count < 65535,
            "The model is too big (more than 65535 vertices)")
    
    // Open external binary buffer file and allocate the fitting memory
    char *bufferUri = data->buffer_views->buffer->uri;
    HANDLE bufferFile = CreateFileA(bufferUri, GENERIC_READ, FILE_SHARE_READ,
                                    NULL, OPEN_EXISTING, 0, NULL);
    u64 bufferSize = data->buffers->size;
    signed char *bufferData = MemAlloc(&memory, bufferSize);
    
    // Read the buffer and copy wanted data to my model
    CheckIf(ReadFile(bufferFile, bufferData, bufferSize, NULL, NULL),
            "Failed to read file (File API error 0x%x)", GetLastError());
    
    // Allocate and retrieve indices data
    model.indicesCount = data->meshes->primitives->indices->count;
    model.indicesSize = data->meshes->primitives->indices->buffer_view->size;
    u32 indicesOffset = data->meshes->primitives->indices->buffer_view->offset;
    model.indices = MemAlloc(&memory, model.indicesSize);
    memcpy(model.indices, bufferData + indicesOffset, model.indicesSize);      

    // Allocate and retrieve vertices data
    cgltf_primitive *primitive = &data->meshes->primitives[0];
    cgltf_attribute *attributes = primitive->attributes;
    u32 verticesCount = primitive->attributes->data->count;
    
    model.verticesSize = verticesCount * sizeof(Vertex);
    model.vertices = MemAlloc(&memory, model.verticesSize);
    
    for (u32 i = 0; i < primitive->attributes_count; ++i)
    {
      u32 offset = attributes[i].data->buffer_view->offset;
      u32 size = attributes[i].data->buffer_view->size;
      
      TmpMemory tmp = {0};
      MemTmpBegin(&tmp, &memory);
      
      switch (attributes[i].type)
      {          
        case cgltf_attribute_type_position: {    
          u16 *currentBuffer = (u16 *)MemAlloc(&memory, size);
          memcpy(currentBuffer, bufferData + offset, size);
          for (u32 j = 0; j < verticesCount; ++j, currentBuffer += 4)
          {
            model.vertices[j].x = currentBuffer[0];
            model.vertices[j].y = currentBuffer[1];
            model.vertices[j].z = currentBuffer[2];
          }
        } break;

        case cgltf_attribute_type_normal: {
          s8 *currentBuffer = (s8 *)MemAlloc(&memory, size);
          memcpy(currentBuffer, bufferData + offset, size);
          for (u32 j = 0; j < verticesCount; ++j, currentBuffer += 4)
          {
            model.vertices[j].nx = currentBuffer[0];
            model.vertices[j].ny = currentBuffer[1];
            model.vertices[j].nz = currentBuffer[2];
          }
        } break;
        
        case cgltf_attribute_type_texcoord: {
          u16 *currentBuffer = (u16 *)MemAlloc(&memory, size);
          memcpy(currentBuffer, bufferData + offset, size);
          for (u32 j = 0; j < verticesCount; j += 2, currentBuffer += 2)
          {
            model.vertices[j].u = currentBuffer[0];
            model.vertices[j].v = currentBuffer[1];
          }
        } break;

        default: break;
      }  
      MemTmpEnd(&tmp, true);
    }
    
    CloseHandle(bufferFile);
    cgltf_free(data);
  }

  HANDLE output = CreateFile(outputPath, GENERIC_WRITE, 0, NULL, CREATE_ALWAYS,
                             0, NULL);
  
  CheckIf(output != INVALID_HANDLE_VALUE,
          "Failed to write to %s", argv[2]);
  CheckIf(WriteFile(output, &model.indicesCount, sizeof(u32), 0, NULL),
    "Failed to write indices count");
  CheckIf(WriteFile(output, &model.indicesSize, sizeof(u32), 0, NULL),
    "Failed to write indices size");
  CheckIf(WriteFile(output, &model.verticesSize, sizeof(u32), 0, NULL),
    "Failed to write vertices size");
  CheckIf(WriteFile(output, model.indices, model.indicesSize, 0, NULL),
    "Failed to write indices");
  CheckIf(WriteFile(output, model.vertices, model.verticesSize, 0, NULL),
    "Failed to write vertices");

  LARGE_INTEGER c2;
  QueryPerformanceCounter(&c2);
  f32 time = (float)((double)(c2.QuadPart - c1.QuadPart) / freq.QuadPart);
  
  DWORD dwFileSize = GetFileSize(output, NULL);
  Log("Converted successfully %s (%ld bytes, %fs)", argv[2], dwFileSize, time);
  
  CloseHandle(output);
  return 0;
}
