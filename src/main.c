/*
  This is an implementation to convert a valid gltf model generated by
  gltfpack tool (https://github.com/zeux/meshoptimizer/releases/v0.20) to
  the simplest single-mesh binary model file I could handle for now.

                             FILE STRUCTURE
                      +--------------------------+
                      |          HEADER          |
                      +--------------------------+
                      |IndicesCount  : u32       |
                      |IndicesSize   : u32       |
                      |VerticesCount : u32       |
                      |VerticesSize  : u32       |
                      |uvScale       : f32[2]    |
                      |uvOffset      : f32[2]    |
                      +--------------------------+
                      |       GEOMETRY DATA      |
                      +--------------------------+
                      |Indices       : u16 *     |
                      |Vertices      : Vertex *  |
                      +--------------------------+
       TODO: meshoptimizer lib impl. w\ same parmams than gltfpack
*/

#include "stdio.h"

#define WIN32_LEAN_AND_MEAN
#include "windows.h"

#define CGLTF_IMPLEMENTATION
#ifndef NDEBUG
#define CGLTF_VALIDATE_ENABLE_ASSERTS 1
#endif
#include "cgltf.h"

#include "typedefs.c"
#include "arena.c"
#include "win32_logger.c"

typedef struct {
  u16 x, y, z;
  i8 nx, ny, nz;
  u16 u, v;
} Vertex;

typedef struct
{
  // Header
  u32 indicesCount;
  u32 indicesSize;
  u32 verticesCount;
  u32 verticesSize;
  f32 uvScale[2];
  f32 uvOffset[2];

  // Geometry data
  u16 *indices;
  Vertex *vertices;
} Model;

int main(int argc, char **argv)
{ 
  if (argc != 3) {
    Log("Usage: gltf2custom [input: *.gltf/glb] [output]");
    return 1;
  }

  LARGE_INTEGER freq, c1;
  QueryPerformanceFrequency(&freq);
  QueryPerformanceCounter(&c1);
  
  Model model = {0};
  char *inputPath = argv[1];
  char *outputPath = argv[2];
  
  Memory memory = {0};
  MemInit(
    &memory, 
    VirtualAlloc(NULL, 1*GB, MEM_COMMIT | MEM_RESERVE, PAGE_READWRITE),
    4*GB
  );

  cgltf_options options = {0};
  cgltf_data* data = NULL;
  CheckIf(cgltf_parse_file(&options, inputPath, &data) == cgltf_result_success, 
    "Failed to parse %s", argv[1]);
  CheckIf(data->meshes_count == 1,
          "The model must be a single mesh")
  CheckIf(data->meshes->primitives_count == 1,
          "The model's primitives must be merged to a single mesh")
  CheckIf(data->meshes->primitives->type == cgltf_primitive_type_triangles,
          "The model must be triangulated and rendered as is (strip and fan modes not supported)")
  CheckIf(data->meshes->primitives->attributes->data->count < 65535,
          "The model is too big (more than 65535 vertices)")
  
  cgltf_material *material = &data->materials[0];
  if (material != NULL && material->has_pbr_metallic_roughness)
  {
    cgltf_texture_transform transform = 
      material->pbr_metallic_roughness.base_color_texture.transform;
    
    model.uvOffset[0] = transform.offset[0];
    model.uvOffset[1] = transform.offset[1];
    model.uvScale[0] = transform.scale[0];
    model.uvScale[1] = transform.scale[1];
  }
  
  char *bufferUri = data->buffer_views->buffer->uri;
  HANDLE bufferFile = CreateFileA(bufferUri, GENERIC_READ, FILE_SHARE_READ,
                                  NULL, OPEN_EXISTING, 0, NULL);
  u64 bufferSize = data->buffers->size;
  signed char *bufferData = MemAlloc(&memory, bufferSize);
  
  CheckIf(ReadFile(bufferFile, bufferData, bufferSize, NULL, NULL),
          "Failed to read file");
  CloseHandle(bufferFile);
  
  model.indicesCount = data->meshes->primitives->indices->count;
  model.indicesSize = data->meshes->primitives->indices->buffer_view->size;
  u32 indicesOffset = data->meshes->primitives->indices->buffer_view->offset;
  model.indices = MemAlloc(&memory, model.indicesSize);
  memcpy(model.indices, bufferData + indicesOffset, model.indicesSize);      

  cgltf_primitive *primitive = &data->meshes->primitives[0];
  cgltf_attribute *attributes = primitive->attributes;
  model.verticesCount = attributes->data->count;
  model.verticesSize = model.verticesCount * sizeof(Vertex);
  model.vertices = MemAlloc(&memory, model.verticesSize);
  
  for (u32 i = 0; i < primitive->attributes_count; ++i)
  {
    u32 offset = attributes[i].data->buffer_view->offset;
    u32 size = attributes[i].data->buffer_view->size;
    
    TmpMemory tmp = {0};
    MemTmpBegin(&tmp, &memory);
    
    switch (attributes[i].type)
    {          
      case cgltf_attribute_type_position: {    
        u16 *currentBuffer = (u16 *)MemAlloc(&memory, size);
        memcpy(currentBuffer, bufferData + offset, size);
        for (u32 j = 0; j < model.indicesCount; ++j, currentBuffer += 4)
        {
          model.vertices[j].x = currentBuffer[0];
          model.vertices[j].y = currentBuffer[1];
          model.vertices[j].z = currentBuffer[2];
        }
      } break;

      case cgltf_attribute_type_normal: {
        i8 *currentBuffer = (i8 *)MemAlloc(&memory, size);
        memcpy(currentBuffer, bufferData + offset, size);
        for (u32 j = 0; j < model.verticesCount; ++j, currentBuffer += 4)
        {
          model.vertices[j].nx = currentBuffer[0];
          model.vertices[j].ny = currentBuffer[1];
          model.vertices[j].nz = currentBuffer[2];
        }
      } break;
      
      case cgltf_attribute_type_texcoord: {
        u16 *currentBuffer = (u16 *)MemAlloc(&memory, size);
        memcpy(currentBuffer, bufferData + offset, size);
        for (u32 j = 0; j < model.verticesCount; ++j, currentBuffer += 2)
        {
          model.vertices[j].u = currentBuffer[0];
          model.vertices[j].v = currentBuffer[1];
        }
      } break;

      default: break;
    }  
    MemTmpEnd(&tmp, true);
  }
  
  cgltf_free(data);

  HANDLE output = CreateFile(outputPath, GENERIC_WRITE, 0, NULL, CREATE_ALWAYS,
                             0, NULL);
  
  CheckIf(output != INVALID_HANDLE_VALUE,
          "Failed to write to %s", argv[2]);
  CheckIf(WriteFile(output, &model.indicesCount, 4 * sizeof(u32), 0, NULL),
    "Failed to write indices or vertices metadata in the header");
  CheckIf(WriteFile(output, &model.uvScale, 4 * sizeof(f32), 0, NULL),
    "Failed to write uv metadata in the header");
  CheckIf(WriteFile(output, model.indices, model.indicesSize, 0, NULL),
    "Failed to write indices");
  CheckIf(WriteFile(output, model.vertices, model.verticesSize, 0, NULL),
    "Failed to write vertices");

  LARGE_INTEGER c2;
  QueryPerformanceCounter(&c2);
  f32 time = (float)((double)(c2.QuadPart - c1.QuadPart) / freq.QuadPart);
  
  DWORD dwFileSize = GetFileSize(output, NULL);
  Log("Converted successfully %s (%ld bytes, %fs)", argv[2], dwFileSize, time);
  
  CloseHandle(output);
  return 0;
}
